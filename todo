Meet 19 Abr:
- 1. Recovery: 
    - Log maior, 90% do número de request/checkpoint
    - Parar de ver o recovery
- 2. Cliente: 
    - criar uma outra configuração de client que não aguarde resposta para lançar uma nova requisição, continua gerando requisições. Objetivo: ver como isso afeta a taxa de chegada no servidor.
    - pode gerar problemas: memória overflow
    - sleep (50 millis)
- 3. Voltar para o joelho:
    - Verificar o número de threads do servidor, usar (4, 8)
    - sleep (50 millis)
- 4. Latencia: pegar por amostragem, ex 10% das requisições dos clientes, para reduzir o tanto de chamadas do sistema (system.nano). Deixar o log raw e fazer as métricas do eixo X por instante. Ver tese do Everaldo, página 63, Fig 19.
   - Latencia: usar percentil
   - Vazação: usar valor médio



Meet: abr 22
- Cliente: Criar uma outra configuração de client que não aguarde resposta para lançar uma nova requisição, continua gerando requisições.  Objetivo: ver como isso afeta a taxa de chegada no servidor.
- Latencia: pegar por amostragem, ex 10% das requisições dos clientes, para reduzir o tanto de chamadas do sistema (system.nano). Deixar o log raw e fazer as métricas do eixo X por instante. Ver tese do Everaldo, página 63, Fig 19.
- Recovery:
-- Fixar o tamanho do estado (número de chaves únicas iguais, 1GB de estado total)
-- Fixar o tamanho do log (usar 50% do tamanho do estado, usar 50% do total de requisições/do CP)
-- Todas as barras de não-particionado devem ter estado de tamanho semelhante. As barras amarelas iram crescer de acordo com a periodicidade para todo mundo.


Meet: mar 17

Latencia = usar percentil
Vazação = usar valor médio

1. rever joelho (usar média ao invés de percentil e descobrir o 70%)
2. ver vales sem checkpoint (tentar 100% read para ver se é culpa da escrita??)
3. verificar pq no parallel=false depois dos checkpoints não tem pico de request
4. Everaldo tinha dois clientes: um esperava resposta e outro não. Verificar se é isso que tá afetando o não enfileramento (sem pico depois do cp). O cliente que espera utilizar para ver a latencia do cliente e o que não espera usar para o resto.
5. Ver logs das recuperações que estão com 0 operações de logs ou muito pouco.
6. Ver gráficos das recuperação:
    6.1. Rever cores dos gráficos, tem que ter apenas 4 cores.
    6.2. Rever calculo das barras dos tempos (ao invés de usar o deltaT, usar o último tempo)



Meet: mar 03 2022

Gráficos primeiro

Recovery:
    1. gráfico
    2. verificar se está reprocessando comandos dos logs q já estão no checkpoint

Vazão média:
    técnicas: sem checkpoint vs particionada vs tradicional
    
    Gráfico de barras agrupadas:
    Y=vazao média (técnicas diferentes de particionamento - cada uma barra)
    X=intervalo de checkpoints diferentes

Checkpoint:
    1. Arrumar checkpoints statics vs antecipados.
    2. Pensar numa fila round-robin.
